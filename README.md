# ■ 背景・目的
- Rustのお勉強のため
- atmarkIT の RUST お勉強講座
  - URL: https://atmarkit.itmedia.co.jp/ait/series/24844/

# ■ 講座の内容
## ▼ 第一回
- MicrosoftとGoogleが採用
- 高い安全性を保ちながら、並列性を担保し、細かなリソース操作も可能にしたプログラミング言語
  - メモリ安全性（メモリ利用における安全性が言語によって保証されていること）を実現
  - ネイティブコンパイラ言語ならではのコンパクトさと高速性を持つ
  - メモリなどのリソースの細やかな取り回しが可能
  - C/C++の弱点といわれる低い並列性、ポインタに代表される危険性を克服

- 現在のネイティブコンパイラ言語
  - 動的にポインタの有効性などをチェックするのは性能とのトレードオフの関係にあり、一般的には行われていない
  - JavaやC#といった中間言語型の言語では動的なチェックを行っていますが、性能的には不利

- Rustの制約
  - 「ボローチェッカー」
    - メモリなどのリソースの所有者とリソースの生存期間（ライフタイム）の静的解析をする仕組み
  - リソースと所有者を1対1にする
    - ある変数がオブジェクトを所有するとして、そのオブジェクトは他の変数では所有できないようにする
    - 変数の消滅とオブジェクトの破棄というライフタイムを管理できる

- 制約に伴う効果
  - ライフタイムを管理できるのでオブジェクトの破棄タイミングをコンパイラが把握でき、不要になったタイミングですぐに破棄できる
    - GC（ガベージコレクタ）が不要ということ

- コンパクトで高速なコンパイラ型言語
  - Rustのコンパイラは、Clangと同様にLLVMと呼ばれる仮想コンパイラプラットフォームに基づいたコンパイル機構に準拠
  - LLVMの中間コードにいったん変換されたあと、最終的にターゲットとなるCPUで動作可能なバイナリを生成

- マルチスレッドプログラミングへの対応
  - C/C++
    - スレッドセーフでないことがたびたび問題視される
      - Cの一部の標準ライブラリ関数ではstatic（静的）な変数を使っているため、複数のスレッドから関数を呼び出すことで競合が発生する可能性がある
      - 変数をロックして競合の問題を回避したとしても、今度はロック解除待ちが相互に発生するデッドロックの問題もある
      - 現在はpthreadsといったPOSIX準拠のマルチスレッド対応ライブラリの登場で状況は変わっているが、外部ライブラリに頼らざるを得ない状況は変わっていない
  - Rust
    - 標準ライブラリにマルチスレッドの機能が用意されているので、スレッドセーフが保証されている

- 自動テスト機能
- モジュールシステムとパッケージマネジャーCargo
- Rustのドキュメント（マニュアル）
  - 日本語のドキュメントを読むことができる

- Rustのプログラム
  - 主要なプログラム
    - rustup：Rustのツールチェーンを管理
      - Rustをインストール、アップデートしたりアンインストールしたりする
    - rustc：Rustコンパイラ
      - 中間言語、実行バイナリ、静的ライブラリ、動的ライブラリをソースコードから生成する
    - cargo：パッケージマネジャー（ビルドツール）
      - Rustのビルドツール
      - プロジェクトのビルド、テスト、外部ライブラリのダウンロード、ドキュメントの作成

- プロジェクト
  - Rustでは、アプリケーションを「プロジェクト」という単位で管理

- パッケージ
  - プロジェクトにおける機能の単位

- パッケージの作成
```shell
% pwd
/Users/nao/Documents/atmarkit_rust
% cargo new --bin hello_world
    Created binary (application) `hello_world` package
%
```

- フォルダ構成
  - src
    - ソースファイルの置き場所
  - target
    - コンパイル結果の置き場所
    - デフォルトではデバッグターゲットのためのdebugフォルダが作成される
    - cargo runに--releaseオプションを与えるとリリースターゲットとなる
      - releaseフォルダが作成されてそこに成果物が置かれる

## ▼ 第二回
- コメント
  - /* ~~ */
  - //

- 変数
  - 変数の宣言
    - let文
    - `let x = 100;`
      - 「値100をxに拘束する」
  - 変数を書き換える
    - ```rust
      let x = 100;
      x = 200;
      ```
    - 参照: variables/src/bin/let1.rs
    - Rustの変数は、変数と言いながら、デフォルトでは値の変更ができない（不変であるとも言う）。
      - これがRustの安全性を高める仕組みの一つ。
    - C/C++とは逆のアプローチである
      - 値を変更できないようにするには、const修飾子を付けたり、final修飾子を付けて宣言したりする
      - しかし、わざわざ付けないとならないので、値を変更してはいけないのに変更できてしまう、それがバグのもとになる、というのがRustの考え
  - 変数を書き換え可能にする
    - 値を変更しても構わない変数は、指定する必要がある。
    - 「mut」を付けて変数を宣言する。
    - `let mut x = 100;`

- 定数
  - `const TAX_RATE: f64 = 1.1;`
    - f64型の定数TAX_RATEを、1.1という値で宣言
  - Rustでは、定数にも型が必要。
  - 関数外で宣言し、プログラム全体から参照するような使い方はC/C++と変わらない。
  - 「mutを付けない変数と定数は同じではないか」
    - 定数は定数式しか代入できない。
    - 変数は任意の式を代入できる。

- 変数名と定数名
  - 全ての英文字（大文字小文字）、数字、アンダースコア（_）が使える（数字で始まるのは不可）。
  - 変数名（関数名なども）の命名規則はスネークケース
  - 定数名は、全て大文字で単語の間をアンダースコア（_）で区切る

- 文と式
  - 文は実行するためのもので、値を持たない。
  - 式は最終的に1つの値になるまで演算が行われるもの。
    - 式は必ず単一の値を持ち、式にセミコロンは必要なし。

- データ型
  - Rustは静的に型付けをするプログラミング言語なので、全ての値や変数、定数はデータ型がコンパイル時に決まる必要がある。
  - スカラー型
    - 整数型
      - 整数型ではi32が基準型

      | 大きさ             | 符号付き | 符号なし |
      |--------------------|----------|----------|
      | 8bit               | i8       | u8       |
      | 16bit              | i16      | u16      |
      | 32bit              | i32      | u32      |
      | 64bit              | i64      | u64      |
      | 128bit             | i128     | u128     |
      | アーキテクチャ依存 | isize    | usize    |

    - 浮動小数点型
      - f32とf64があり、それぞれ32bit、64bitのサイズを持ち、基準型はf64。
      - f32は単精度浮動小数点数、f64は倍精度浮動小数点数を表現。
    
    - 論理値型
      - 真偽を表すデータ型
      - データ型はboolで、値はtrueとfalseしかとらない。
    
    - 文字型
      - 文字を表すデータ型
      - データ型はchar
        - C/C++のcharも文字型だが、これはASCIIコード（7bit）を表すのに対して、
          RustのcharはUnicodeを表す。
          - よって、日本語などの文字も表現できる。

- 基準型
  - 型注釈のない変数宣言などで、優先して選択されるデータ型
  - 例えば、整数型の変数xを宣言したいとき、以下のように書かれていれば、
    i32すなわち32bitの符号付き整数として宣言されたと見なされる。
    ```rust
    let x = 10;     // i32
    let y = 3.14;   // f64
    ```

- 型注釈
  - Rustでは、データ型を型注釈という形で指定する。
  - 上記の変数宣言を型注釈付きで示すと以下のようになる。
    ```rust
    let x: i32 = 10;     // i32
    let y: f64 = 3.14;   // f64
    ```

- タプル型
  - 複数のスカラー型の値をまとめて扱えるデータ型。
  - スカラー型がそれぞれ異なっていても扱うことができる。
  - C/C++における構造体のように見えるが、それぞれの値に名前はない。
  - 参照: variables/src/bin/tuple1.rs
  - ```rust
    let t = (2, 3.14, 0);
    let (a, b, c) = t;
    println!("a={}, b={}, c={}", a, b, c);  // a=2, b=3.14, c=0
    let x = t.0;
    let y = t.1;
    let z = t.2;
    println!("x={}, y={}, z={}", x, y, z);  // x=2, y=3.14, z=0
    ```
  - 個別に取り出す場合、インデックスは0から始まる。
  - またインデックスは以下の配列と同様のチェックが行われて、
    範囲外のインデックスが指定された場合にエラーが発生する。

- 配列型
  - ```rust
    let a = [1, 2, 3, 4, 5];
    let x = a[0];
    let y = a[1];
    let z = a[2];
    println!("x={}, y={}, z={}", x, y, z);  // x=1, y=2, z=3
    ```
  - 一度宣言した配列の要素数を変更することはできない。
    - この欠点を克服する手段として、コレクションライブラリが用意されている。
  - 有効ではないインデックスでのアクセスという問題
    - C/C++では予期しない動作となって現れる。
    - Java/C#では実行時に例外で捕捉される。
    - Rustでは、このチェックはコンパイル時と実行時に行われる。
    - 参照: variables/src/bin/array2.rs