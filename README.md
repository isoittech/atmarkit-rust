# ■ 背景・目的
- Rustのお勉強のため
- atmarkIT の RUST お勉強講座
  - URL: https://atmarkit.itmedia.co.jp/ait/series/24844/

# ■ 講座の内容
## ▼ 第一回
- MicrosoftとGoogleが採用
- 高い安全性を保ちながら、並列性を担保し、細かなリソース操作も可能にしたプログラミング言語
  - メモリ安全性（メモリ利用における安全性が言語によって保証されていること）を実現
  - ネイティブコンパイラ言語ならではのコンパクトさと高速性を持つ
  - メモリなどのリソースの細やかな取り回しが可能
  - C/C++の弱点といわれる低い並列性、ポインタに代表される危険性を克服

- 現在のネイティブコンパイラ言語
  - 動的にポインタの有効性などをチェックするのは性能とのトレードオフの関係にあり、一般的には行われていない
  - JavaやC#といった中間言語型の言語では動的なチェックを行っていますが、性能的には不利

- Rustの制約
  - 「ボローチェッカー」
    - メモリなどのリソースの所有者とリソースの生存期間（ライフタイム）の静的解析をする仕組み
  - リソースと所有者を1対1にする
    - ある変数がオブジェクトを所有するとして、そのオブジェクトは他の変数では所有できないようにする
    - 変数の消滅とオブジェクトの破棄というライフタイムを管理できる

- 制約に伴う効果
  - ライフタイムを管理できるのでオブジェクトの破棄タイミングをコンパイラが把握でき、不要になったタイミングですぐに破棄できる
    - GC（ガベージコレクタ）が不要ということ

- コンパクトで高速なコンパイラ型言語
  - Rustのコンパイラは、Clangと同様にLLVMと呼ばれる仮想コンパイラプラットフォームに基づいたコンパイル機構に準拠
  - LLVMの中間コードにいったん変換されたあと、最終的にターゲットとなるCPUで動作可能なバイナリを生成

- マルチスレッドプログラミングへの対応
  - C/C++
    - スレッドセーフでないことがたびたび問題視される
      - Cの一部の標準ライブラリ関数ではstatic（静的）な変数を使っているため、複数のスレッドから関数を呼び出すことで競合が発生する可能性がある
      - 変数をロックして競合の問題を回避したとしても、今度はロック解除待ちが相互に発生するデッドロックの問題もある
      - 現在はpthreadsといったPOSIX準拠のマルチスレッド対応ライブラリの登場で状況は変わっているが、外部ライブラリに頼らざるを得ない状況は変わっていない
  - Rust
    - 標準ライブラリにマルチスレッドの機能が用意されているので、スレッドセーフが保証されている

- 自動テスト機能
- モジュールシステムとパッケージマネジャーCargo
- Rustのドキュメント（マニュアル）
  - 日本語のドキュメントを読むことができる

- Rustのプログラム
  - 主要なプログラム
    - rustup：Rustのツールチェーンを管理
      - Rustをインストール、アップデートしたりアンインストールしたりする
    - rustc：Rustコンパイラ
      - 中間言語、実行バイナリ、静的ライブラリ、動的ライブラリをソースコードから生成する
    - cargo：パッケージマネジャー（ビルドツール）
      - Rustのビルドツール
      - プロジェクトのビルド、テスト、外部ライブラリのダウンロード、ドキュメントの作成

- プロジェクト
  - Rustでは、アプリケーションを「プロジェクト」という単位で管理

- パッケージ
  - プロジェクトにおける機能の単位

- パッケージの作成
```shell
% pwd
/Users/nao/Documents/atmarkit_rust
% cargo new --bin hello_world
    Created binary (application) `hello_world` package
%
```

- フォルダ構成
  - src
    - ソースファイルの置き場所
  - target
    - コンパイル結果の置き場所
    - デフォルトではデバッグターゲットのためのdebugフォルダが作成される
    - cargo runに--releaseオプションを与えるとリリースターゲットとなる
      - releaseフォルダが作成されてそこに成果物が置かれる

## ▼ 第二回
- コメント
  - /* ~~ */
  - //

- 変数
  - 変数の宣言
    - let文
    - `let x = 100;`
      - 「値100をxに拘束する」
  - 変数を書き換える
    - ```rust
      let x = 100;
      x = 200;
      ```
    - 参照: variables/src/bin/let1.rs
    - Rustの変数は、変数と言いながら、デフォルトでは値の変更ができない（不変であるとも言う）。
      - これがRustの安全性を高める仕組みの一つ。
    - C/C++とは逆のアプローチである
      - 値を変更できないようにするには、const修飾子を付けたり、final修飾子を付けて宣言したりする
      - しかし、わざわざ付けないとならないので、値を変更してはいけないのに変更できてしまう、それがバグのもとになる、というのがRustの考え
  - 変数を書き換え可能にする
    - 値を変更しても構わない変数は、指定する必要がある。
    - 「mut」を付けて変数を宣言する。
    - `let mut x = 100;`

- 定数
  - `const TAX_RATE: f64 = 1.1;`
    - f64型の定数TAX_RATEを、1.1という値で宣言
  - Rustでは、定数にも型が必要。
  - 関数外で宣言し、プログラム全体から参照するような使い方はC/C++と変わらない。
  - 「mutを付けない変数と定数は同じではないか」
    - 定数は定数式しか代入できない。
    - 変数は任意の式を代入できる。

- 変数名と定数名
  - 全ての英文字（大文字小文字）、数字、アンダースコア（_）が使える（数字で始まるのは不可）。
  - 変数名（関数名なども）の命名規則はスネークケース
  - 定数名は、全て大文字で単語の間をアンダースコア（_）で区切る

- 文と式
  - 文は実行するためのもので、値を持たない。
  - 式は最終的に1つの値になるまで演算が行われるもの。
    - 式は必ず単一の値を持ち、式にセミコロンは必要なし。

- データ型
  - Rustは静的に型付けをするプログラミング言語なので、全ての値や変数、定数はデータ型がコンパイル時に決まる必要がある。
  - スカラー型
    - 整数型
      - 整数型ではi32が基準型

      | 大きさ             | 符号付き | 符号なし |
      |--------------------|----------|----------|
      | 8bit               | i8       | u8       |
      | 16bit              | i16      | u16      |
      | 32bit              | i32      | u32      |
      | 64bit              | i64      | u64      |
      | 128bit             | i128     | u128     |
      | アーキテクチャ依存 | isize    | usize    |

    - 浮動小数点型
      - f32とf64があり、それぞれ32bit、64bitのサイズを持ち、基準型はf64。
      - f32は単精度浮動小数点数、f64は倍精度浮動小数点数を表現。
    
    - 論理値型
      - 真偽を表すデータ型
      - データ型はboolで、値はtrueとfalseしかとらない。
    
    - 文字型
      - 文字を表すデータ型
      - データ型はchar
        - C/C++のcharも文字型だが、これはASCIIコード（7bit）を表すのに対して、
          RustのcharはUnicodeを表す。
          - よって、日本語などの文字も表現できる。

- 基準型
  - 型注釈のない変数宣言などで、優先して選択されるデータ型
  - 例えば、整数型の変数xを宣言したいとき、以下のように書かれていれば、
    i32すなわち32bitの符号付き整数として宣言されたと見なされる。
    ```rust
    let x = 10;     // i32
    let y = 3.14;   // f64
    ```

- 型注釈
  - Rustでは、データ型を型注釈という形で指定する。
  - 上記の変数宣言を型注釈付きで示すと以下のようになる。
    ```rust
    let x: i32 = 10;     // i32
    let y: f64 = 3.14;   // f64
    ```

- タプル型
  - 複数のスカラー型の値をまとめて扱えるデータ型。
  - スカラー型がそれぞれ異なっていても扱うことができる。
  - C/C++における構造体のように見えるが、それぞれの値に名前はない。
  - 参照: variables/src/bin/tuple1.rs
  - ```rust
    let t = (2, 3.14, 0);
    let (a, b, c) = t;
    println!("a={}, b={}, c={}", a, b, c);  // a=2, b=3.14, c=0
    let x = t.0;
    let y = t.1;
    let z = t.2;
    println!("x={}, y={}, z={}", x, y, z);  // x=2, y=3.14, z=0
    ```
  - 個別に取り出す場合、インデックスは0から始まる。
  - またインデックスは以下の配列と同様のチェックが行われて、
    範囲外のインデックスが指定された場合にエラーが発生する。

- 配列型
  - ```rust
    let a = [1, 2, 3, 4, 5];
    let x = a[0];
    let y = a[1];
    let z = a[2];
    println!("x={}, y={}, z={}", x, y, z);  // x=1, y=2, z=3
    ```
  - 一度宣言した配列の要素数を変更することはできない。
    - この欠点を克服する手段として、コレクションライブラリが用意されている。
  - 有効ではないインデックスでのアクセスという問題
    - C/C++では予期しない動作となって現れる。
    - Java/C#では実行時に例外で捕捉される。
    - Rustでは、このチェックはコンパイル時と実行時に行われる。
    - 参照: variables/src/bin/array2.rs

## ▼ 第三回
- 数値リテラル

  | 数値リテラル   | 接頭辞 | 接尾辞                                                         | 例                                   |
  |----------------|--------|----------------------------------------------------------------|--------------------------------------|
  | 整数（10進数） | なし   | i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize  | 123 369i16 45_678_u32                |
  | 整数（16進数） | 0x     | ^                                                               | 0xffff 0x88 0xaa_u8                  |
  | 整数（8進数）  | 0o     | ^                                                               | 0o11 0o55 0o77_u8                    |
  | 整数（2進数）  | 0b     | ^                                                               | 0b00001111 0b1111_0000 0b01010101_u8 |
  | 整数（バイト） | b      | ―                                                               | b'A' b'9'                            |
  | 浮動小数点数   | なし   | f32, f64                                                        | 1.23 9.87f32, 4.56_f64               |

- 文字列リテラル
  - Rustには、言語仕様に文字列型というものはない。
  - 文字列はStringというライブラリで実装される。
  - 文字列リテラルとは何かというと、ダブルクォーテーションで囲まれた文字の連続のこと。
  - `let str = "Hello, world!";`

- 式と演算子
  - 一覧
    | **演算の種類** | **演算子** | **例**         | **説明**                   |
    |----------------|------------|----------------|----------------------------|
    | **代入演算**   | =          | var = expr     | 代入                       |
    | **数値演算**   | +          | expr + expr    | 加算                       |
    | ^               | +=         | var += expr    | 加算後に代入               |
    | ^               | -          | - expr         | 算術否定                   |
    | ^               | -          | expr - expr    | 減算                       |
    | ^               | -=         | var -= expr    | 減算後に代入               |
    | ^               | *          | expr * expr    | 乗算                       |
    | ^               | *=         | var *= expr    | 乗算後に代入               |
    | ^               | /          | expr / expr    | 除算                       |
    | ^               | /=         | var /= expr    | 除算後に代入               |
    | ^               | %          | expr % expr    | 剰余演算                   |
    | ^               | %=         | var %= expr    | 剰余演算後に代入           |
    | **比較演算**   | ==         | expr == expr   | 等価比較                   |
    | ^               | !=         | expr != expr   | 非等価比較                 |
    | ^               | <          | expr < expr    | 小なり比較                 |
    | ^               | <=         | expr <= expr   | 以下比較                   |
    | ^               | ">"          | expr > expr    | 大なり比較                 |
    | ^               | >=         | expr >= expr   | 以上比較                   |
    | **論理演算**   | !          | !expr          | ビット反転、または論理反転 |
    | ^               | &&         | expr && expr   | 論理AND                    |
    | ^               | \|\|       | expr \|\| expr | 論理OR                     |
    | **ビット演算** | &          | expr & expr    | ビットAND                  |
    | ^               | &=         | var &= expr    | ビットAND後に代入          |
    | ^               | \|         | expr \| expr   | ビットOR                   |
    | ^               | \|=        | var \|= expr   | ビットOR後に代入           |
    | ^               | ^          | expr ^ expr    | ビットXOR                  |
    | ^               | ^=         | var ^= expr    | ビットXOR後に代入          |
    | ^               | <<         | expr << expr   | 左シフト                   |
    | ^               | <<=        | var <<= expr   | 左シフト後に代入           |
    | ^               | >>         | expr >> expr   | 右シフト                   |
    | ^               | >>=        | var >>= expr   | 右シフト後に代入           |

  - インクリメント演算子（++）とデクリメント演算子（--）はない。
    - 複合演算子（+=, -=）で代替可能
    - 前置と後置で評価結果が変わり、バグの原因になりやすいことから実装していない説

- if式、else式、else if式

  - ```rust
    let age = 15;   // 年齢
    if age >= 25 {                                  // 条件式はfalseとなる
        println!("選挙権と被選挙権があります。");   // 実行されない
    } else if age >= 18 {                           // 条件式はfalseとなる
        println!("選挙権のみがあります。");         // 実行されない
    } else {
        println!("選挙権も被選挙権もありません。"); // 実行される
    }
    ```

- if式の値を利用する

  - ```rust
    let age = 15;   // 年齢
    let s = if age >= 25 {  // sをif式の結果で初期化。条件式はfalseとなる
        "選挙権と被選挙権があります。"      // if式の値にならない
    } else if age >= 18 {                   // 条件式はfalseとなる
        "選挙権のみがあります。"            // if式の値にならない
    } else {
        "選挙権も被選挙権もありません。"    // if式の値になる
    };                                      // セミコロンが必要
    println!("{}", s);                      // 「選挙権も被選挙権もありません。」
    ```
  - 値を返すif式にする場合は、以下の点に気を付ける。
    - 全てのブロックの式が同じデータ型に評価されている必要がある
    - 式なのでセミコロンを省略しても問題ない
    - let文の一部に当たるため、if式の最後にlet文の終わりを示すセミコロンが必要になる

- 条件式
  - 条件式は必ず論理値を返すbool型の結果にする。

- 条件分岐（match式）

  - ```rust
    let letter = 'S';
    let str = match letter {                                // letterでマッチングする
        'Z' => "アルファベット最後の文字",                  // 単一値のマッチング
        'S' | 'M' | 'L' => "サイズを表すアルファベット",    // 複数値のマッチング
        '0'..='9' | 'A'..='F' => "16進数で使う文字",        // 範囲を指定したマッチング
        _ => "いずれでもない文字",                          // いずれにもマッチしなかった場合
    };
    println!("{}は{}です。", letter, str);
    ```
  - パターンは全てのケースを網羅する。
    - アンダースコア（_）によるパターンがあれば取りあえず満たせる。
    - そうでない場合はくまなくパターンを記述する必要がある。
  - 「パターン => 実行する文および式」はカンマ（,）で区切る。
  - 文および式が複数になる場合には中かっこ（{ }）で囲ってブロックにする。
  - パターンは定数である必要がなく、式も指定できる。
    - この場合でも、全てのケースを網羅するようにする。


- while式
  - ```rust
    let max = 10;
    let mut count = 1;
    let mut sum = 0;
    while count <= max {
        sum += count;
        count += 1;
    }
    println!("{}までの合計は{}です。", max, sum);   // 「10までの合計は55です。」    
    ```
  - if式とmatch式は条件分岐の結果としての値を返すことができたが、while式では値を返すことはできない。
    - 正確には、空のタプルである()が返される。

- for式
  - ```rust
    let scores = [90, 80, 85, 70, 95];      // 点数の配列
    for score in scores.iter() {                    // for式で回す
        println!("点数は{}点です。", score);        // 配列の要素数だけ実行される
    }    
    ```
    ```
    % cargo run --bin for1
    点数は90点です。
    点数は80点です。
    点数は85点です。
    点数は70点です。
    点数は95点です。
    ```
  - iter()メソッドはイテレータ（繰り返し記述子）で、コレクションの中身を順番に変数に与えるために使用する。
  - for式も、while式と同様に空のタプルである()が返される。

- loop式
  - ```rust
    loop {                          // 永遠に続くのでCtrl＋Cを入力して止める
        println!("線路は続くよ、どこまでも。");
    }    
    ```
  - 止め方は後で考えるので取りあえず実行してほしいというケースで使う。
    - 終了条件が明確なのにloop式を安易に利用するのは非推奨。
  - loop式は値を返すことができ、値を返すにもbreak式を使う。

- break式
  - ```rust
    let scores = [90, 20, 100, 40, 60];
    let mut i = 0;
    let f = loop {
        if scores[i] == 100 {     // 配列に100が見つかれば中断してインデックスを返す
            break i;
        }
        i += 1;
    };
    println!("満点が要素{}にありました。", f);      // 「満点が要素2にありました。」    
    ```
  - break式を使うと、繰り返しをその時点で止められる。
  - loop式として値を返すことができる。
  - break式の値は省略できる。
    - 省略した場合、単純にループを中断するだけになるが、loop式が値を返すことはできなくなる。
  - while式もfor式もbreak式を利用できるが、loop式のように値を返すことはできない。
    - while、forのbreakは中断のみの用途になる。

- continue式
  - ```rust
    let scores = [90, 20, 100, 40, 60];
    let mut i = 5;
    while i > 0 {
        i -= 1;
        if scores[i] == 100 {     // 配列に100が見つかれば次の繰り返しに移す
            continue;
        }
        println!("満点でない点数{}が要素{}にありました。", scores[i], i);
    }    
    ```
    ```
    % cargo run --bin continue1
    満点でない点数60が要素4にありました。
    満点でない点数40が要素3にありました。
    満点でない点数20が要素1にありました。
    満点でない点数90が要素0にありました。    
    ```
  - continue式は値を返すためには使えない。